<h1>Why Roda?</h1>

<p>There are already plenty of ruby web frameworks. Why another one? Well, Roda has a very useful combination of features that make web development easy.  It's designed to be fast, <acronym title="Don't Repeat Yourself">DRY</acronym>, and correct.  It's probably easiest to explain the advantages by comparing it with Sinatra, which it tries to emulate in many respects.</p>

<h2>Advantages over Sinatra</h2>

<p>The primary advantage that Roda offers over Sinatra is that it uses a routing tree, while Sinatra uses a simple list of routes.  At any point in the routing tree, you can operate on the current route.  If your URLs reflect your application architecture, this allows you to have much DRYer code.  Let's examine code examples for the a simple app, implemented in both Sinatra and Roda:</p>

<div class="col-md-6">
Roda:
<pre><code>require 'roda'

class App &lt; Roda
  plugin :render

  route do |r|
    r.get '' do
      view :index
    end

    r.on 'artist/:id' do |artist_id|
      @artist = Artist[artist_id]

      r.is do
        r.get do
          view :artist
        end

        r.post do
          @artist.update(params[:artist])
          r.redirect(r.full_path_info)
        end
      end

      r.on 'album/:number' do |album_number|
        @album = @artist.album_with_number(album_number)

        r.is do
          r.get do
            view :album
          end

          r.post do
            @album.update(params[:album])
            r.redirect(r.full_path_info)
          end
        end

        r.on 'track/:track_num' do |track_num|
          @track = @album.track_with_number(track_num)

          r.is do
            r.get do 
              view :track
            end

            r.post do
              @track.update(params[:track])
              r.redirect(r.full_path_info)
            end
          end
        end
      end
    end
  end
end
</code></pre>
</div>

<div class="col-md-6">
Sinatra:
<pre><code>require 'sinatra/base'

class App &lt; Sinatra::Base
  get '/' do
    erb :index
  end

  get '/artist/:id' do
    @artist = Artist[params[:id]]
    erb :artist
  end

  post '/artist/:id' do
    @artist = Artist[params[:id]]
    @artist.update(params[:artist])
    redirect(request.path_info)
  end

  get '/artist/:id/album/:number' do
    @artist = Artist[params[:id]]
    @album = @artist.album_with_number(params[:number])
    erb :album
  end

  post '/artist/:id/album/:number' do
    @artist = Artist[params[:id]]
    @album = @artist.album_with_number(params[:number])
    @album.update(params[:album])
    redirect(request.path_info)
  end

  get '/artist/:id/album/:number/track/:track_num' do
    @artist = Artist[params[:id]]
    @album = @artist.album_with_number(params[:number])
    @track = @album.track_with_number(params[:track_num])
    erb :track
  end

  post '/artist/:id/album/:number/track/:track_num' do
    @artist = Artist[params[:id]]
    @album = @artist.album_with_number(params[:number])
    @track = @album.track_with_number(params[:track_num])
    @track.update(params[:track])
    redirect(request.path_info)
  end
end
</code></pre>
</div>

<p style="clear: both;">While the Roda code is slightly more lines, it should be apparent that it is actually much simpler.  Instead of setting the @artist, @album, and/or @track variables in every route that uses them, the variables are set as soon as that branch of the tree is taken, and can be used in all routes under that branch.  This is why Roda is called a routing tree web framework. In all but the smallest applications, this usually results in much DRYer and easier to maintain code.</p>

<p>In addition to being more maintainable, Roda's approach is also much faster in general.  This is because Sinatra is doing more work to determine which route to take compared to Roda.  Let's say you are going to <span class="path">/artist/1/album/2/track/3</span>.  What Sinatra is going to do is check each route in order, comparing the request method and route against the full path of the request, and if it doesn't match, starting again with the next route.  With Roda, as soon as part of the route matches, that part does not need to be rechecked every time.  Also, the request method is only checked once at the end to determine whether to take get or post as the final branch.</p>

<p>Another advantage Roda brings over Sinatra is that it has a plugin system modeled on Sequel's.  All parts of Roda (class/instance/request/response) can be overridden by plugins and call super to get the default behavior.  This includes when plugins are applied to the Roda class itself (affecting all subclasses).  Roda has a very small core, and many features that are built-in Sinatra are shipped as plugins in Roda. This way they can easily used if needed, but if you don't use them you don't pay the cost for loading them.  Near the top of the Roda example, there is the call to load the render plugin, which adds support for template rendering, as the default Roda code doesn't ship with template support.</p>

<p>Finally, Roda, being a &quot;tree&quot;, is very concerned about pollution.  In this case, pollution of the scope in which the route block operates.  Roda purposely limits the instance variables, instance methods, and class namespaces available in the route block scope, so that it is very unlikely you will run into conflicts.  If you've ever tried to use an instance variable named @request or a model named Response inside a Sinatra::Base subclass, you'll appreciate that Roda attempts to avoid polluting the scope.</p>
